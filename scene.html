<html>
	<head>
		<title>Scene</title>
		<script type="text/javascript" src="js/three.js"></script>
        <script type="text/javascript" src="js/jquery-2.1.3.min.js"></script>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	<div id="WebGL-output"></div>
	<script type="text/javascript">
		$(document).ready(function()
		{
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var cameraControls = new THREE.OrbitControls(camera);

            var renderer = new THREE.WebGLRenderer({antialias : true});
            renderer.setClearColor(0xEEEEEE);
            renderer.setSize( window.innerWidth, window.innerHeight );
                
            var axisHelper = new THREE.AxisHelper(20);

            $(window).on("resize", function()
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                update();
            });

            camera.position.x = -60;
            camera.position.y = 50;
            camera.position.z = -40;
            camera.lookAt(new THREE.Vector3(20,0,15));
            camera.updateProjectionMatrix();
            $(cameraControls).on("change", renderScene);
            cameraControls.target = new THREE.Vector3(20,0,15);

            // interactive controls
			var controls = new function()
			{
				this.color = 0xff0000;
				this.x = 0.0;
				this.y = 0.0;
				this.z = 0.0;
				this.showControlPoints = true;
				this.bezierCurves = 51;
				this.interactiveCamera = true;
				this.axisHelper = false;
				this.asWireframe = false;
				this.drawAuxSurface = true;
				this.drawDebugElements = false;
			}

			var gui = new dat.GUI({width:370});
			gui.addColor(controls, "color").name("Color").onChange(function(c)
			{
				cameraControls.enabled = false;
				update();
				$(document).on("mouseup", function(e)
                {
                    $(document).off("mouseup");
                    cameraControls.enabled = true;  // enabling camera controls again
                });
			});
			
			var curvesController = gui.add(controls, "bezierCurves").min(10).max(100).step(1).name("Bezier Curves");
			curvesController.onChange(function(n)
			{
				console.log("bezierCurves::onChange");
				cameraControls.enabled = false;

			});
			curvesController.onFinishChange(function(n)
			{
				console.log("bezierCurves::onFinishChange");

				cameraControls.enabled = true;
				update();
				renderScene();
			});

			gui.add(controls, "interactiveCamera").name("Interactive Camera").onChange(function(v) {
				cameraControls.enabled = v;
			});

			gui.add(controls, "axisHelper").name("Show Axis Helper").onChange(function(v) {
				update();
			});
			var controlx, controly, controlz;
			gui.add(controls, "showControlPoints").name("Show Control Points").onChange(function(visibility)
			{
				update();
			});
			gui.add(controls, "asWireframe").name("Vizualize as Wireframe").onChange(function(v)
			{
				update();
			});
			gui.add(controls, "drawAuxSurface").name("Draw aux surface").onChange(function(v)
			{
				update();
			});
			

			var bezierCurveDivisions = 50;
            var controlPoints = [];

            var meshSize = 4;
            var x = -5;
            var y = 0;
            var z = -5;
            var step = 15;
            for(var i = 0; i < meshSize; i++)
            {
            	controlPoints.push([]);
            	for(var j = 0; j < meshSize; j++)
            	{
            		controlPoints[i].push(new THREE.Vector3(x + j * step, y, z + i * step));
            	}
            }

            var controlPointsSpheres = [];

			var sourceCylinder;
			var sourceCylinderPos = new THREE.Vector3(40, 35, 17);

			var uvSurfaceVertices = [];

			function checkLinePlaneIntersection(planeNormal, lineStart, lineEnd)
			{
				var v = new THREE.Vector3();
				v.subVectors(lineEnd, lineStart);

				return v.dot(planeNormal) != 0;
			}

			function getLinePlaneIntersectionPoint(planeNormal, planePoint, lineStart, lineEnd)
			{
				if(!checkLinePlaneIntersection(planeNormal, lineStart, lineEnd))
					return new THREE.Vector3();

				var v1p0 =  new THREE.Vector3();
				v1p0.subVectors(planePoint, lineStart);

				var v1v2 =  new THREE.Vector3();
				v1v2.subVectors(lineEnd, lineStart);
				var d = v1p0.dot(planeNormal) / v1v2.dot(planeNormal);

				var intersectionPoint = new THREE.Vector3();
				intersectionPoint.addScaledVector(v1v2, d);
				intersectionPoint.add(lineStart);

				return intersectionPoint;
			}
			
            function drawCubicBezier(controlPoints, color)
            {
                var curve = new THREE.CubicBezierCurve3(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3]);
                var points = curve.getPoints(50);
                var geometry = new THREE.Geometry();

                for(var i = 0; i < points.length; i++)
                {
                    geometry.vertices.push(points[i]);  
                }
                
                var material = new THREE.LineBasicMaterial({ color : color });

                var curveObject = new THREE.Line( geometry, material);
                
                scene.add(curveObject);
            }
                
            function drawBezierSurface(controlPoints, bezierCurveDivisions, color)
            {
                var basicBezierModel = [];  // 4 bezier curves calculated from bezier control points

                // calculating basic bezier model (main 4 bezier curves)
                for (var i = 0; i < controlPoints.length; i++)
                {
                    var bezier = new THREE.CubicBezierCurve3(controlPoints[i][0],
                                                            controlPoints[i][1],
                                                            controlPoints[i][2],
                                                            controlPoints[i][3]);
                
                    basicBezierModel.push(bezier.getPoints(bezierCurveDivisions));
                }

                var bezierCurvesVertices = [];

                // calculating full bezier model (50 bezier curves in one direction, each containing 50 vertices)
                for (var i = 0; i <= bezierCurveDivisions; i++)
                {
                    var bezier = new THREE.CubicBezierCurve3(basicBezierModel[0][i],
                                                           	basicBezierModel[1][i],
                                                            basicBezierModel[2][i],
                                                            basicBezierModel[3][i]);

                    bezierCurvesVertices = bezierCurvesVertices.concat(bezier.getPoints(bezierCurveDivisions));
                }

                // now we've got full bezier model, it's time to create bezier surface and add it to the scene
                var bezierSurfaceVertices = bezierCurvesVertices;
                var bezierSurfaceFaces = [];

                var initUvSurfaceVertices = (uvSurfaceVertices.length == 0);
                if(initUvSurfaceVertices)
                	bezierSurfaceVertices.forEach(function(item, index, array)
                	{
                		uvSurfaceVertices.push(item.clone());
               	 	});

                class EdgeInfo
                {
 
                	constructor(vBeginIndex = -1, vEndIndex = -1, face1Index = -1, face2Index = -1, isdt = -1)
                	{
                		this.vBeginIndex = vBeginIndex;
                		this.vEndIndex = vEndIndex;
                		this.face1Index = face1Index;
                		this.face2Index = face2Index;
                		this.isdt = isdt;
                	}
                }

                class FaceInfo
                {
                	constructor(edgeIndices)
                	{
                		this.edgeIndices = edgeIndices;
                	}

                	getSubsetExcludingIndex(indexToExclude)
                	{
                		var result = [];
                		this.edgeIndices.forEach(function (edgeIndex, index, array)
                		{
                			if(edgeIndex != indexToExclude)
                				result.push(edgeIndex);
                		});

                		return result;
                	}
                }

                class IntersectionInfo
                {
 
                	constructor(u, v, edgeIndex, checked = false)
                	{
                		this.u = u;
                		this.v = v;
                		this.edgeIndex = edgeIndex;
                		this.checked = checked;
                	}

                	clone()
                	{
                		return new IntersectionInfo(this.u, this.v, this.edgeIndex, this.checked);
                	}
                }

                var edgesInfo = [];
                var facesInfo = [];

                // creating faces from vertices
                var currentFaceIndex = 0;
                var v1, v2, v2;  // vertex indices in bezierSurfaceVertices array
                for (var i = 0; i < bezierCurveDivisions; i++)
                {
                    for (var j=0; j < bezierCurveDivisions; j++)
                    {
                        v1 = i * (bezierCurveDivisions + 1) + j;
                        v2 = (i + 1) * (bezierCurveDivisions + 1) + j; 
                        v3 = i * (bezierCurveDivisions + 1) + (j + 1); 
                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));

                        edgesInfo.push(new EdgeInfo(v1, v2, currentFaceIndex - 1, currentFaceIndex)); //e1
                        edgesInfo.push(new EdgeInfo(v2, v3, currentFaceIndex, currentFaceIndex + 1)); //e2
                        edgesInfo.push(new EdgeInfo(v3, v1, currentFaceIndex, i >= 0 ? ((i - 1) * (bezierCurveDivisions + 1) + (j * 2)) : -1)); //e3
                        facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));

                        v1 = (i + 1) * (bezierCurveDivisions + 1) + j; 
                        v2 = (i + 1) * (bezierCurveDivisions + 1) + (j + 1);
                        v3 = i * (bezierCurveDivisions + 1) + (j + 1);
                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));

                        currentFaceIndex++;

                        edgesInfo.push(new EdgeInfo(v1, v2, currentFaceIndex, (i + 1) * (bezierCurveDivisions + 1) + (j * 2))); //e4
                        edgesInfo.push(new EdgeInfo(v2, v3, currentFaceIndex + 1)); //e5
                        edgesInfo.push(new EdgeInfo(v3, v1, currentFaceIndex, currentFaceIndex -  1)); //e6
                        facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));
                    }
                }

                var bezierSurfaceGeometry = new THREE.Geometry();
                bezierSurfaceGeometry.vertices = bezierSurfaceVertices;
                bezierSurfaceGeometry.faces = bezierSurfaceFaces;
                bezierSurfaceGeometry.computeFaceNormals();
                bezierSurfaceGeometry.computeVertexNormals();
                var bezierSurfaceMaterial = new THREE.MeshLambertMaterial({color: color, wireframe: controls.asWireframe});
                var bezierSurface = new THREE.Mesh(bezierSurfaceGeometry, bezierSurfaceMaterial);
                bezierSurface.material.side = THREE.DoubleSide;
                scene.add(bezierSurface);

                //distance surface
                var sourcePoint = sourceCylinderPos.clone();
                sourcePoint.z -= sourceCylinder.geometry.parameters.height / 2;
                var sourceEndPoint = sourceCylinderPos.clone();
                sourceEndPoint.z += sourceCylinder.geometry.parameters.height / 2;
                var sourceDir = new THREE.Vector3();
                sourceDir.subVectors(sourceEndPoint, sourcePoint);

				if(controls.drawDebugElements)
				{
    	            var arrowHelper = new THREE.ArrowHelper(sourceDir, sourcePoint, sourceDir.length(), 0xff0000);
					scene.add(arrowHelper);
				}


				if(controls.drawAuxSurface)
				{
	                var distanceSurfaceVertices = new Array(bezierSurfaceVertices.length);

	                var distaceSurfaceGeometry = new THREE.Geometry();
	                

	                bezierSurfaceFaces.forEach(function(face, index, array)
	                {
	                	function f(vertexIndex, faceVertexIndex)
	                	{
							if(typeof distanceSurfaceVertices[vertexIndex] === "undefined")
							{
								var bxn = new THREE.Vector3();
								bxn.crossVectors(sourceDir, face.vertexNormals[faceVertexIndex]);

								var qa = new THREE.Vector3();
								qa.subVectors(sourcePoint, bezierSurfaceVertices[vertexIndex]);

								var d = bxn.dot(qa) / bxn.length();

								distanceSurfaceVertices[vertexIndex] = new THREE.Vector3(uvSurfaceVertices[vertexIndex].x,
																				   		 y + d,
																				   		 uvSurfaceVertices[vertexIndex].z);
							}
						}

						var faceCopy = face.clone();
						f(faceCopy.a, 0);
						f(faceCopy.b, 1);
						f(faceCopy.c, 2);

						distaceSurfaceGeometry.faces.push(faceCopy);
	                });

	                distaceSurfaceGeometry.vertices = distanceSurfaceVertices;
	                distaceSurfaceGeometry.computeFaceNormals();
	                distaceSurfaceGeometry.computeVertexNormals();
	                var distaceSurfaceMaterial = new THREE.MeshLambertMaterial({color: 0x0000ff, wireframe: controls.asWireframe});
	                var distaceSurface = new THREE.Mesh(distaceSurfaceGeometry, distaceSurfaceMaterial);
	                distaceSurface.material.side = THREE.DoubleSide;
	                scene.add(distaceSurface);

	                var planeNormal = new THREE.Vector3(0, 1, 0);
	                var planePoint = new THREE.Vector3(0, 0, 0);

	                var intersectionsInfo = [];

	                edgesInfo.forEach(function(edge, index, array)
	                {
	                	var edgeStart = distaceSurfaceGeometry.vertices[edge.vBeginIndex].clone();
	                	var edgeEnd = distaceSurfaceGeometry.vertices[edge.vEndIndex].clone();

	                	if(checkLinePlaneIntersection(planeNormal, edgeStart, edgeEnd))
	                	{
	                		var intersectionPoint = getLinePlaneIntersectionPoint(planeNormal, planePoint, edgeStart, edgeEnd);
	                		intersectionsInfo.push(new IntersectionInfo(intersectionPoint.x, intersectionPoint.z, index));
	                		edge.isdt = intersectionsInfo.length - 1;
	                	}
	                });

	                var contours = [];
	                var currentIntersection;

	                var previousIntersection;

	                function getIntersectionForEdge(edgeIndex)
	                {
	                	var result = [];

	                	var isdt = edgesInfo[edgeIndex].isdt;
	                	if(isdt != -1)
	                		result.push(intersectionsInfo[isdt].clone());

	                	return result;
	                }

	                previousIntersection = intersectionsInfo[0];

	                for(var i = 1; i < intersectionsInfo.length; i++)
	                {
	                	intersection = intersectionsInfo[i];

	                	if(!intersection.checked)
	                	{
		                	if(contours.length == 0)
		                		contours.push([]);
		                	if(previousIntersection != null)
		                		contours[contours.length - 1].push(previousIntersection);


		                	var faceIndex = edgesInfo[intersection.edgeIndex].face2Index;
		                	if(faceIndex < 0)
		                	{
		                		contours.push([]);
		                		continue;
		                	}
		                	
		                	var faceInfo = facesInfo[faceIndex];

		                	var otherEdges = faceInfo.getSubsetExcludingIndex(intersection.edgeIndex);

		                	var intersectionFound = false;
		                	for(var j = 0; j < otherEdges.length; j++)
		                	{
		                		var intersections = getIntersectionForEdge(otherEdges[j]);
		                		if(intersections.length == 1)
		                		{
		                			previousIntersection = intersections[0];
		                			intersection.checked = true;
		                			intersectionFound = true;
		                			break;
		                		}
		                	}

		                	if(!intersectionFound)
		                	{
		                		previousIntersection = null;
		                		contours.push([]);
		                	}
		                }
	                }

					contours.forEach(function(contour, index, array)
					{
						var points = [];
						contour.forEach(function(point, index, array)
						{
							points.push(new THREE.Vector3(point.u, 0, point.v));
						});
						//drawLineMultiplePoints(points, 0x000000);
					}); 
	            }

				if(controls.drawDebugElements)
				{
                	scene.add(createSphere(sourcePoint, 0x00ff00));
                	scene.add(createSphere(sourceEndPoint, 0x00ff00));
            	}

                var lightBelow = new THREE.PointLight(0xffffff);
                lightBelow.position.set(20, -40, 20);
                scene.add(lightBelow);

                var lightAbove = new THREE.PointLight(0xffffff);
                lightAbove.position.set(20, 40, 20);
                lightAbove.target = bezierSurface;
                scene.add(lightAbove);
            }

            function createSphere(pos, color, name = "")
            {
            	var sphereGeometry = new THREE.SphereGeometry(0.7, 10, 10);
                            
	            var sphereMaterial = new THREE.MeshBasicMaterial({color: color});
	            var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
	            sphere.name = name;
	            sphere.position.x = pos.x;
	            sphere.position.y = pos.y;
	            sphere.position.z = pos.z;

	            return sphere;
	        }
            
            function generateControlPointsSpheres(controlPoints, spheres, pointsColor)
            {
               var meshSize = controlPoints.length;
               var rowSize = controlPoints[0].length;
                
                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < rowSize; j++)
                    {
                        spheres.push(createSphere(controlPoints[i][j], pointsColor, i.toString() + "-" + j.toString()));
                    }
                }
            }
                
            function drawControlMesh(controlPoints, controlSpheres, pointsColor, linesColor)
            {
                console.log("drawControlMesh");
                
                controlSpheres.length = 0;
                
                generateControlPointsSpheres(controlPoints, controlSpheres, pointsColor);
                                
                var meshSize = controlPoints.length;
                var rowSize = controlPoints[0].length;

                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < rowSize; j++)
                    {
                        scene.add(controlSpheres[i * meshSize + j]);
                        
                        if(j > 0)
                        {
                            drawLine(controlPoints[i][j - 1], controlPoints[i][j], linesColor);
                        }
                        
                        if(i > 0)
                        {
                            drawLine(controlPoints[i - 1][j], controlPoints[i][j], linesColor);
                        }
                    }
                }
            }

            function drawLine(p1, p2, color)
            {

            	drawLineMultiplePoints([p1, p2], color);
            }
            
            function drawLineMultiplePoints(points, color)
            {
                var geometry = new THREE.Geometry();

                geometry.vertices = points;
                
                var material = new THREE.LineBasicMaterial({color : color});
                
                var line = new THREE.Line(geometry, material);
                
                scene.add(line);
            }

            function drawSourceCylinder()
            {

				var cylinderGeometry = new THREE.CylinderGeometry(5, 5, 20, 32);
				cylinderGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 2));
				var opacity = 1.0;
				if(controls.drawDebugElements)
					opacity = 0.5;
				var material = new THREE.MeshLambertMaterial({color: 0xffff00, emissive: 0xffff00, transparent : true,
															  emissiveIntensity : 0.75, opacity : opacity});
				sourceCylinder = new THREE.Mesh(cylinderGeometry, material);
				sourceCylinder.position.x = sourceCylinderPos.x;
				sourceCylinder.position.y = sourceCylinderPos.y;
				sourceCylinder.position.z = sourceCylinderPos.z;
				scene.add(sourceCylinder);
			}
            
            function handleControlSphereClick(selectedSphere)
            {
            	console.log("Control point shpere clicked");

            	renderScene();
                var planeNormal = selectedSphere.position.clone().sub(camera.position);
                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, selectedSphere.position);
                
                $(document).on("mousemove", function(e)
                {
                    console.log("mousemove");
                    var mouseMove = new THREE.Vector3();
                    mouseMove.x = (e.clientX / renderer.domElement.width) * 2 - 1;
                    mouseMove.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
                    mouseMove.z = 1;
                    mouseMove.unproject(camera);
                    var ray = new THREE.Ray(camera.position, mouseMove.sub(camera.position).normalize());
                    var intersection = ray.intersectPlane(plane);
                    
                    selectedSphere.position.set(intersection.x, intersection.y, intersection.z);
                    var i = selectedSphere.name.split("-"); 
                    controlPoints[ i[0] ][ i[1] ] = new THREE.Vector3(intersection.x, intersection.y, intersection.z);
                    update();
                });
            }

			function handleSourceCylinderClick()
            {
            	console.log("Source cylinder clicked");

                var planeNormal = sourceCylinder.position.clone().sub(camera.position);
                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, sourceCylinder.position);
                
                $(document).on("mousemove", function(e)
                {
                    console.log("mousemove");
                    var mouseMove = new THREE.Vector3();
                    mouseMove.x = (e.clientX / renderer.domElement.width) * 2 - 1;
                    mouseMove.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
                    mouseMove.z = 1;
                    mouseMove.unproject(camera);
                    var ray = new THREE.Ray(camera.position, mouseMove.sub(camera.position).normalize());
                    var intersection = ray.intersectPlane(plane);
                    sourceCylinderPos = intersection.clone();
                    update();
                });
            }

            document.addEventListener("mousedown", onClick, true);  
            function onClick(e)
			{
                console.log("mousedown");

				var cursorPos = new THREE.Vector2();
				var raycaster = new THREE.Raycaster();
				
				cursorPos.x = (e.clientX / renderer.domElement.width) * 2 - 1;
				cursorPos.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
				raycaster.setFromCamera(cursorPos, camera);
							
				//check control spheres for intersecdtions
				var intersectedObjects = raycaster.intersectObjects(controlPointsSpheres);
				
				if(intersectedObjects.length > 0)
				{   
	                cameraControls.enabled = false;  // disabling camera rotation
	                
	                var selectedSphere = intersectedObjects[0].object;
	                if(!selectedSphere.visible)
	                {
	                	console.log("intersected sphere invisible");
	                    return;
	                }
	                
	                handleControlSphereClick(selectedSphere);
	            }
	            else
	            {
	            	var intersectedObjects = raycaster.intersectObjects([sourceCylinder]);
	            	if(intersectedObjects.length > 0)
					{   
	                	cameraControls.enabled = false;  // disabling camera 
	                	handleSourceCylinderClick();
	            	}
	            	else
	            	{
	            		console.log("No interactions");
	            		return;
	            	}
	            }
                
                $(document).on("mouseup", function(e)
                {
                    $(document).off("mousemove");
                    $(document).off("mouseup");
                    cameraControls.enabled = true;  // enabling camera controls again
                });
            }

            
            document.addEventListener("keydown", onKeypress);
            function onKeypress(e)
            {
            	console.log("Key pressed : " + e.code);

            	if(e.code == "Space")
            	{
            		controls.drawDebugElements = !controls.drawDebugElements;
            		update();
            	}
            }

            function renderScene()
            {
				renderer.render(scene, camera);
			}
			
			function update()
			{
				while(scene.children.length > 0)
				{ 
    				scene.remove(scene.children[0]); 
				}

				drawSourceCylinder();

				drawBezierSurface(controlPoints, controls.bezierCurves - 1, controls.color);
            	var controlMeshColor = 0x000000;
            	if(controls.showControlPoints)
            		drawControlMesh(controlPoints, controlPointsSpheres, controlMeshColor, controlMeshColor);

            	if(controls.axisHelper)
            		scene.add(axisHelper);

                renderScene();
			}
			 
			$("#WebGL-output").append(renderer.domElement);

			update();
		});
		</script>
	</body>
</html>
