<html>
	<head>
		<title>Scene</title>
		<script type="text/javascript" src="js/three.js"></script>
        <script type="text/javascript" src="js/jquery-2.1.3.min.js"></script>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	<div id="WebGL-output"></div>
	<script type="text/javascript">
		$(document).ready(function()
		{
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var cameraControls = new THREE.OrbitControls(camera);

            var renderer = new THREE.WebGLRenderer({antialias : true});
            renderer.setClearColor(0xEEEEEE);
            renderer.setSize( window.innerWidth, window.innerHeight );
                
            var axisHelper = new THREE.AxisHelper(20);

            $(window).on("resize", function()
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderScene();
            });

            camera.position.x = -60;
            camera.position.y = 50;
            camera.position.z = -40;
            camera.lookAt(new THREE.Vector3(20,0,15));
            camera.updateProjectionMatrix();
            $(cameraControls).on("change", renderScene);
            cameraControls.target = new THREE.Vector3(20,0,15);

            // interactive controls
			var controls = new function()
			{
				this.color = 0xff0000;
				this.x = 0.0;
				this.y = 0.0;
				this.z = 0.0;
				this.showControlPoints = false;
				this.wireframe = false;
				this.bezierCurves = 51;
				this.interactiveCamera = true;
				this.axisHelper = false;
			}
			var gui = new dat.GUI({width:370});
			gui.addColor(controls, "color").name("Color").onChange(function(c)
			{
				cameraControls.enabled = false;
				update();
				$(document).on("mouseup", function(e)
                {
                    $(document).off("mouseup");
                    cameraControls.enabled = true;  // enabling camera controls again
                });
			});
			gui.add(controls, "wireframe").name("Wireframe mode").onChange(function(v) {
				controls.wireframe = v;
				renderScene();
			});
			gui.add(controls, "bezierCurves").min(10).max(100).step(1).name("Bezier Curves").onFinishChange(function(n) {
					bezierCurveDivisions = n-1;  // interpolation will give additional 1 bezier curve
					redrawBezierSurface();
					renderScene();
			});
			gui.add(controls, "interactiveCamera").name("Interactive Camera").onChange(function(v) {
				cameraControls.enabled = v;
			});
			gui.add(controls, "axisHelper").name("Show Axis Helper").onChange(function(v) {
				if(v) scene.add(axisHelper);
				else scene.remove(axisHelper);
				renderScene();
			});
			var controlx, controly, controlz;
			gui.add(controls, "showControlPoints").name("Show Control Points").onChange(function(visibility) {
				if (visibility) {
					controlx = gui.add(controls, "x").listen();
					controly = gui.add(controls, "y").listen();
					controlz = gui.add(controls, "z").listen();
				} else {
					gui.remove(controlx);
					gui.remove(controly);
					gui.remove(controlz);
				}
				updateActivePointControls();
				setControlPointsVisibility(visibility);
				renderScene();
			});
			
			function updateActivePointControls() {
				controls.x = activeControlPoint.position.x;
				controls.y = activeControlPoint.position.y;
				controls.z = activeControlPoint.position.z;
				controls.x.toFixed(2);
			}

            var controlPoints = [[new THREE.Vector3(-10, 10, 0),
                                new THREE.Vector3(0, 7, 0),
                                new THREE.Vector3(15, 3, 0),
                                new THREE.Vector3(30, 8, 0)],
                                [new THREE.Vector3(-10, 0, 10),
                                new THREE.Vector3(-5, 15, 10),
                                new THREE.Vector3(20, 10, 10),
                                new THREE.Vector3(30, 5, 10)],
                                [new THREE.Vector3(-10, 5, 20),
                                new THREE.Vector3(-5,-10, 20),
                                new THREE.Vector3(10, 10, 20),
                                new THREE.Vector3(30, 0, 20)],
                                [new THREE.Vector3(-10, 4, 30),
                                new THREE.Vector3(-5, 8, 30),
                                new THREE.Vector3(20, 6, 30),
                                new THREE.Vector3(30, 4, 30)]];
    
            var controlPointsSpheres = [];
            
            function drawCubicBezier(controlPoints, color)
            {
                var curve = new THREE.CubicBezierCurve3(controlPoints[0], controlPoints[1], controlPoints[2], controlPoints[3]);
                var points = curve.getPoints(50);
                var geometry = new THREE.Geometry();

                for(var i = 0; i < points.length; i++)
                {
                    geometry.vertices.push(points[i]);  
                }
                
                var material = new THREE.LineBasicMaterial({ color : color });

                var curveObject = new THREE.Line( geometry, material);
                
                scene.add(curveObject);
            }
                
            function drawBezierSurface(controlPoints, bezierCurveDivisions, color, wireframe)
            {
                var basicBezierModel = [];  // 4 bezier curves calculated from bezier control points

                // calculating basic bezier model (main 4 bezier curves)
                for (var i = 0; i < controlPoints.length; i++)
                {
                    var bezier = new THREE.CubicBezierCurve3(controlPoints[i][0],
                                                            controlPoints[i][1],
                                                            controlPoints[i][2],
                                                            controlPoints[i][3]);
                
                    basicBezierModel.push(bezier.getPoints(bezierCurveDivisions));
                }

                var bezierCurvesVertices = [];

                // calculating full bezier model (50 bezier curves in one direction, each containing 50 vertices)
                for (var i = 0; i <= bezierCurveDivisions; i++)
                {
                    var bezier = new THREE.CubicBezierCurve3(basicBezierModel[0][i],
                                                            basicBezierModel[1][i],
                                                            basicBezierModel[2][i],
                                                            basicBezierModel[3][i]);

                    bezierCurvesVertices = bezierCurvesVertices.concat(bezier.getPoints(bezierCurveDivisions));
                }

                // now we've got full bezier model, it's time to create bezier surface and add it to the scene
                var bezierSurfaceVertices = bezierCurvesVertices;
                var bezierSurfaceFaces = [];

                // creating faces from vertices
                var v1, v2, v2;  // vertex indices in bezierSurfaceVertices array
                for (var i = 0; i < bezierCurveDivisions; i++)
                {
                    for (var j=0; j < bezierCurveDivisions; j++)
                    {
                        v1 = i * (bezierCurveDivisions + 1) + j;
                        v2 = (i + 1) * (bezierCurveDivisions + 1) + j;
                        v3 = i * (bezierCurveDivisions + 1) + (j + 1);
                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));
                            
                        v1 = (i + 1) * (bezierCurveDivisions + 1) + j;
                        v2 = (i + 1) * (bezierCurveDivisions + 1) + (j + 1);
                        v3 = i * (bezierCurveDivisions + 1) + (j + 1);
                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));
                    }
                }

                var bezierSurfaceGeometry = new THREE.Geometry();
                bezierSurfaceGeometry.vertices = bezierSurfaceVertices;
                bezierSurfaceGeometry.faces = bezierSurfaceFaces;
                bezierSurfaceGeometry.computeFaceNormals();
                bezierSurfaceGeometry.computeVertexNormals();
                var bezierSurfaceMaterial = new THREE.MeshLambertMaterial({color: color, wireframe: wireframe});
                var bezierSurface = new THREE.Mesh(bezierSurfaceGeometry, bezierSurfaceMaterial);
                bezierSurface.material.side = THREE.DoubleSide;
                scene.add(bezierSurface);
                    
                // all kinds of lights
                var ambientLight = new THREE.AmbientLight(0x0c0c0c);
                scene.add(ambientLight);

                var spotLightBelow = new THREE.SpotLight(0xffffff);
                spotLightBelow.position.set(20, -40, 20);
                spotLightBelow.target = bezierSurface;
                spotLightBelow.exponent = 5;
                scene.add(spotLightBelow);

                var spotLightAbove = new THREE.SpotLight(0xffffff);
                spotLightAbove.position.set(20,40,20);
                spotLightAbove.target = bezierSurface;
                spotLightAbove.exponent = 3;
                scene.add(spotLightAbove);
            }
            
            function generateControlPointsSpheres(controlPoints, spheres, pointsColor)
            {
               var meshSize = controlPoints.length;
                
                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < meshSize; j++)
                    {
                        var controlPointSphereGeometry = new THREE.SphereGeometry(0.7, 10, 10);
                            
                        var controlSphereMaterial = new THREE.MeshBasicMaterial({color: pointsColor});
                        var controlSphere = new THREE.Mesh(controlPointSphereGeometry, controlSphereMaterial);
                        controlSphere.name = + i.toString() + "-" + j.toString();
                        controlSphere.position.x = controlPoints[i][j].x;
                        controlSphere.position.y = controlPoints[i][j].y;
                        controlSphere.position.z = controlPoints[i][j].z;
                        spheres.push(controlSphere)
                    }
                }
            }
                
            function drawControlMesh(controlPoints, controlSpheres, pointsColor, linesColor)
            {
                console.log("drawControlMesh");
                
                controlSpheres.length = 0;
                
                generateControlPointsSpheres(controlPoints, controlSpheres, pointsColor);
                                
                var meshSize = controlPoints.length;
                
                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < meshSize; j++)
                    {
                        scene.add(controlSpheres[i * meshSize + j]);
                        
                        if(j > 0)
                        {
                            drawLine(controlPoints[i][j - 1], controlPoints[i][j], linesColor);
                        }
                        
                        if(i > 0)
                        {
                            drawLine(controlPoints[i - 1][j], controlPoints[i][j], linesColor);
                        }
                    }
                }
            }
            
            function drawLine(p1, p2, color)
            {
                var geometry = new THREE.Geometry();
                geometry.vertices.push(p1);
                geometry.vertices.push(p2);
                
                var material = new THREE.LineBasicMaterial({color : color});
                
                var line = new THREE.Line(geometry, material);
                
                scene.add(line);
            }
            
            document.addEventListener("mousedown", onClick, true);  // done with pure javascript (without jquery because jquery doesn't support event capturing, which is essential if we want to avoid bugs with mousedown event, which is used for both rotation and placement of control points)
			function onClick(e)
			{
                console.log("mousedown");

				var cursorPos = new THREE.Vector2();
				var raycaster = new THREE.Raycaster();
				
				cursorPos.x = (e.clientX / renderer.domElement.width) * 2 - 1;
				cursorPos.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
				raycaster.setFromCamera(cursorPos, camera);
							
				var intersectedObjects = raycaster.intersectObjects(controlPointsSpheres);
				
				if(intersectedObjects.length == 0)
				{
                    console.log("no intersections");
                    return;
				}
				
                cameraControls.enabled = false;  // disabling camera rotation
                
                var selectedSphere = intersectedObjects[0].object;
                if(!selectedSphere.visible)
                {
                	console.log("intersected sphere invisible");
                    return;
                }
                
                renderScene();
                var planeNormal = selectedSphere.position.clone().sub(camera.position);
                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, selectedSphere.position);
                
                $(document).on("mousemove", function(e)
                {
                    console.log("mousemove");
                    var mouseMove = new THREE.Vector3();
                    mouseMove.x = (e.clientX / renderer.domElement.width) * 2 - 1;
                    mouseMove.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
                    mouseMove.z = 1;
                    mouseMove.unproject(camera);
                    var ray = new THREE.Ray(camera.position, mouseMove.sub(camera.position).normalize());
                    var intersection = ray.intersectPlane(plane);
                    
                    selectedSphere.position.set(intersection.x, intersection.y, intersection.z);
                    var i = selectedSphere.name.split("-");  // active control point index
                    controlPoints[ i[0] ][ i[1] ] = new THREE.Vector3(intersection.x, intersection.y, intersection.z);
                    update();
                });
                
                $(document).on("mouseup", function(e)
                {
                    $(document).off("mousemove");
                    $(document).off("mouseup");
                    cameraControls.enabled = true;  // enabling camera controls again
                });
            }
                    
            function renderScene()
            {
				renderer.render(scene, camera);
			}
			
			function update()
			{
				while(scene.children.length > 0)
				{ 
    				scene.remove(scene.children[0]); 
				}

				drawBezierSurface(controlPoints, 50, controls.color, false);
            	var controlMeshColor = 0x000000;
            	drawControlMesh(controlPoints, controlPointsSpheres, controlMeshColor, controlMeshColor);
                renderScene();
			}
			
			$("#WebGL-output").append(renderer.domElement);

			update();
		});
		</script>
	</body>
</html>
