<html>
	<head>
		<title>Scene</title>
		<script type="text/javascript" src="js/three.js-master/build/three.js"></script>
        <script type="text/javascript" src="js/jquery-2.1.3.min.js"></script>
        <script type="text/javascript" src="js/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
<!-- 		<button onclick="document.getElementById('file-input').click();">Open</button>
 -->		<input id="fileInput" type="file" name="name" style="display: none;"/>
	<div id="WebGL-output"></div>
	<script type="text/javascript">

		function last(array)
		{
			if(array.length == 0)
				return null;

			return array[array.length - 1];
		}

		let localizationMap = new Map([
  										['loadFile', new Map([['BG', 'Отвори файл'], ['EN', 'Load File']])],
  										['reflectionWidth', new Map([['BG', 'Ширина на линията'], ['EN', 'Line width']])],
  										['color', new Map([['BG', 'Цвят'], ['EN', 'Color']])],
  										['interactiveCamera', new Map([['BG', 'Интерактивна камера'], ['EN', 'Interactive Camera']])],
  										['showAxisHelper', new Map([['BG', 'Покажи помощна КС'], ['EN', 'Show Axis Helper']])],
  										//['showControlPoints', new Map([['BG', 'Покажи контролните точки'], ['EN', 'Show Control Points']])],
  										['vizualizeAsWireframe', new Map([['BG', 'Покажи мрежа'], ['EN', 'Vizualize As Wireframe']])],
  										['scale', new Map([['BG', 'Мащабиране'], ['EN', 'Scale']])]		
									  ]);

		function getLocalizationForLanguage(key, language)
		{
			var keyTranslations = localizationMap.get(key);
			if(keyTranslations === "undefined")
			{
				console.log("No localization input for " + key);
				return "";
			}
			else
			{
				return keyTranslations.get(language);
			}
		}

		$(document).ready(function()
		{
			var isTriangleSurface = false;

			var triSurfaceDegree = 0;
			var trianglesControlPoints = [];
			var trianglesControlPointsScaled = [];
			var controlPointsArr = [];
			var controlPointsArrScaled = [];

			var fileInput = document.getElementById('fileInput');

			fileInput.addEventListener('change', function(e)
			{
				var file = fileInput.files[0];
				var textType = /text.*/;

				if (file.type.match(textType))
				{
					var reader = new FileReader();

					reader.onload = function(e)
					{
						if(reader.result[0] == 't')
							parseTriangularSurfaces(reader.result.substring(2));
						else if(reader.result[0] == 'r')
							parseRectangularSurfaces(reader.result.substring(2));

						update();
					}

					reader.readAsText(file);	
				}
				else
				{
					fileDisplayArea.innerText = "File not supported!"
				}
			});

			function clearScene()
			{
				scaleController.setValue(1.0);

				controlPointsArr = [];
				trianglesControlPoints = [];

				controlPointsArrScaled = [];
				trianglesControlPointsScaled = [];
			}

			function parseRectangularSurfaces(str)
			{
				//r
				//1 //surfaces count
				//4
				//(x, y, z), (x, y, z), ...
				//....

				clearScene();

				var firstNewLineIndex = str.indexOf("\n");
				var surfacesCount = parseInt(str.substring(0, firstNewLineIndex));
				
				for(var surfacesIndex = 0; surfacesIndex < surfacesCount; ++surfacesIndex)
				{
					str = str.substring(firstNewLineIndex + 1);
					firstNewLineIndex = str.indexOf("\n");
					meshSize = parseInt(str.substring(0, firstNewLineIndex));

					controlPointsArr.push([]);
					for(var i = 0; i < meshSize; ++ i)
					{
						controlPointsArr[surfacesIndex].push([]);

						str = str.substring(firstNewLineIndex + 1);
						firstNewLineIndex = str.indexOf("\n");

						var line = str.substring(0, firstNewLineIndex);

						for(var j = 0; j < meshSize; ++j)
						{
							var firstOpeningBracketIndex = line.indexOf("("); 
							var firstClosingBracketIndex = line.indexOf(")");
							var pointStr = line.substring(firstOpeningBracketIndex + 1, firstClosingBracketIndex);

							var values = pointStr.split(",");

							if(values.length != 3)
							{
								//do something
							}
							else
							{
								controlPointsArr[surfacesIndex][i].push(new THREE.Vector3(parseFloat(values[0]),
																				   		  parseFloat(values[1]),
																				   		  parseFloat(values[2])));
							}

							line = line.substring(firstClosingBracketIndex + 1); 
						}
					
					}
				}
			}

			function parseTriangularSurfaces(str)
			{
				//t
				//1 //surfaces count
				//3
				//(x, y, z), (x, y, z), ...

				clearScene();
				
				var firstNewLineIndex = str.indexOf("\n");
				var surfacesCount = parseInt(str.substring(0, firstNewLineIndex));

				for(var surfacesIndex = 0; surfacesIndex < surfacesCount; ++surfacesIndex)
				{
					
					
					firstNewLineIndex = str.indexOf("\n");

					str = str.substring(firstNewLineIndex + 1);
					firstNewLineIndex = str.indexOf("\n");
					triSurfaceDegree = parseInt(str.substring(0, firstNewLineIndex));

					trianglesControlPoints.push([]);

					let currentRowPointsCount = 1;
					for(var i = 0; i < triSurfaceDegree + 1; ++ i)
					{
						str = str.substring(firstNewLineIndex + 1);
						firstNewLineIndex = str.indexOf("\n");

						var line = str.substring(0, firstNewLineIndex);

						for(var j = 0; j < currentRowPointsCount; ++j)
						{
							var firstOpeningBracketIndex = line.indexOf("("); 
							var firstClosingBracketIndex = line.indexOf(")");
							var pointStr = line.substring(firstOpeningBracketIndex + 1, firstClosingBracketIndex);

							var values = pointStr.split(",");

							if(values.length != 3)
							{
								//do something
							}
							else
							{
								trianglesControlPoints[surfacesIndex].push(new THREE.Vector3(parseFloat(values[0]),
																				   		  	parseFloat(values[1]),
																				   		  	parseFloat(values[2])));
							}

							line = line.substring(firstClosingBracketIndex + 1); 
						}
						currentRowPointsCount++;
					}
				}
			}

            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000 );
            var cameraControls = new THREE.OrbitControls(camera);

            var renderer = new THREE.WebGLRenderer({antialias : true});
            renderer.setClearColor(0xEEEEEE);
            renderer.setSize( window.innerWidth, window.innerHeight );
                
            var axisHelper = new THREE.AxesHelper(20);

            $(window).on("resize", function()
            {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                update();
            });

            camera.position.x = -100;
            camera.position.y = 0;
            camera.position.z = 0;

            camera.lookAt(new THREE.Vector3(0, 0, 0));
            camera.updateProjectionMatrix();
            $(cameraControls).on("change", renderScene);
            cameraControls.target = new THREE.Vector3(0, 0, 0);

            var lightBelow = new THREE.PointLight(0xffffff);
            lightBelow.position.set(0, -200, 0);

            var lightAbove = new THREE.PointLight(0xffffff);
            lightAbove.position.set(0, 200, 0);

            var lightLeft = new THREE.PointLight(0xffffff);
            lightLeft.position.set(-200, 0, 0);
            var lightRight = new THREE.PointLight(0xffffff);
            lightRight.position.set(0, 0, 200);

            // interactive controls
			var controls = new function()
			{
				this.color = 0xff0000;
				this.radius = 2;
				this.reflectionWidth = 1;
				this.showControlPoints = false;
				this.interactiveCamera = true;
				this.showAxisHelper = false;
				this.vizualizeAsWireframe = false;
				this.drawAuxSurface = false;
				this.drawDebugElements = false;
				this.projectCurves = true;
				this.drawPlane = true;
				this.lang = 'EN';
				this.scale = 1.0;
			}

			cameraControls.enabled = controls.interactiveCamera;

			function getLocalization(key)
			{
				return getLocalizationForLanguage(key, controls.lang);
			}

			var gui = new dat.GUI({width:370});

			var params = {
    						loadFile : function()
    						{ 
            					document.getElementById("fileInput").click();
    						},

    						changeLang : function()
    						{
    							if(controls.lang == 'EN')
									controls.lang = 'BG'

					 			else if(controls.lang == 'BG')
									controls.lang = 'EN'
							}
						};

			var controllers = new Map();

			var langControl = gui.add(params, "changeLang").name(controls.lang);

			controllers.set("loadFile", gui.add(params, "loadFile").name(getLocalization('loadFile')));

			controllers.set("color", gui.addColor(controls, "color").name(getLocalization('color')).onChange(function(c)
			{
				cameraControls.enabled = false;
				update();
				$(document).on("mouseup", function(e)
                {
                    $(document).off("mouseup");
                    cameraControls.enabled = controls.interactiveCamera;  // enabling camera controls again
                });
			}));

			var radiusController = gui.add(controls, "reflectionWidth").min(0).max(7).step(1).name(getLocalization('reflectionWidth'));
			radiusController.onChange(function(n)
			{
				cameraControls.enabled = false;
			});
			radiusController.onFinishChange(function(n)
			{
				cameraControls.enabled = controls.interactiveCamera;
				update();
				renderScene();
			});

			controllers.set("reflectionWidth", radiusController);

			controllers.set("interactiveCamera", gui.add(controls, "interactiveCamera").name(getLocalization('interactiveCamera')).onChange(function(v) 
			{
				cameraControls.enabled = v;
			}));

			controllers.set("showAxisHelper", gui.add(controls, "showAxisHelper").name(getLocalization('showAxisHelper')).onChange(function(v) {
				update();
			}));
		
			controllers.set("vizualizeAsWireframe", gui.add(controls, "vizualizeAsWireframe").name(getLocalization('vizualizeAsWireframe')).onChange(function(v)
			{
				update();
			}));

			var scaleController = gui.add(controls, "scale").min(0.1).max(100).step(0.1).name(getLocalization('scale'));
			scaleController.onChange(function(n)
			{
				cameraControls.enabled = false;
			});
			scaleController.onFinishChange(function(n)
			{
				cameraControls.enabled = controls.interactiveCamera;
				handlePlaneScale(n);
			});
			controllers.set("scale", scaleController);

			langControl.onFinishChange(function()
			{
				langControl.name(controls.lang);

				if(!(controllers === "undefined"))
				{
					controllers.forEach(function(value, key, map)
					{
						value.name(getLocalization(key));
					});
				}
			});

            var controlPointsSpheres = [];

			var sourceCylinder;
			var sourceCylinderPos = new THREE.Vector3(40, 35, 17);

			var uvSurfaceVertices = [];

			function equal(a, b)
			{
				var dif = Math.abs(a - b);
				return dif < 0.0001;
			}

			function checkLinePlaneIntersection(planeNormal, lineStart, lineEnd)
			{
				var v = new THREE.Vector3();
				v.subVectors(lineEnd, lineStart);

				return !equal(v.dot(planeNormal), 0);
			}

			function getLinePlaneIntersectionPoint(planeNormal, c, lineStart, lineEnd)
			{
				if(!checkLinePlaneIntersection(planeNormal, lineStart, lineEnd))
					return null;

				var plane = new THREE.Plane(planeNormal, c);
				var intersectionPoint = new THREE.Vector3();

				if(typeof plane.intersectLine(new THREE.Line3(lineStart, lineEnd), intersectionPoint) === "undefined")
					return null;

				return intersectionPoint;
			}

			function bezierCurvePoint(currentIterationPoints, t)
			{
				var nextIterationPoints = [];

				while(nextIterationPoints.length != 1)
				{
					nextIterationPoints = Array();
					for(var i = 0; i < currentIterationPoints.length - 1; ++i)
					{
						var x = (currentIterationPoints[i].x * (1 - t)) + (currentIterationPoints[i + 1].x * t); 
						var y = (currentIterationPoints[i].y * (1 - t)) + (currentIterationPoints[i + 1].y * t);
						var z = (currentIterationPoints[i].z * (1 - t)) + (currentIterationPoints[i + 1].z * t);
				
						nextIterationPoints.push(new THREE.Vector3(x, y, z));
					}
					currentIterationPoints = nextIterationPoints;
				}

				return nextIterationPoints[0].clone();
			}

			function bezierCurvePoints(controlPoints, divisions = 51)
			{
				var curvePoints = [];

				var currentIterationPoints = controlPoints.slice();
				var nextIterationPoints = Array();

				var step = 1.0 / divisions;
	
				for(var t = 0.0; t <= 1.001; t += step)
				{
					curvePoints.push(bezierCurvePoint(controlPoints.slice(), t));
				}

				return curvePoints;
			}

			function getSurfacePointAt(u, v, controlPoints)
			{
				var secondaryControlPoints = [];

				controlPoints.forEach(function (controlPointsRow, index, array)
				{
					secondaryControlPoints.push(bezierCurvePoint(controlPointsRow, u));
				});

				return bezierCurvePoint(secondaryControlPoints, v);
			}

			class uv
			{
				constructor(u = 0, v = 0)
				{
					this.u = u;
					this.v = v;
				}
			}

			function getUv(divisions)
			{
				var uvs = [];

				var step = 1.0 / divisions;
	
				for(var u = 0.0; u <= 1.001; u += step)
				{
					for(var v = 0.0; v <= 1.001; v += step)
					{
						uvs.push(new uv(u, v));
					}
				}

				return uvs;
			}

			class EdgeInfo
            {
 
                constructor(vBeginIndex = -1, vEndIndex = -1, face1Index = -1, face2Index = -1, isdt = -1)
                {
                	this.vBeginIndex = vBeginIndex;
                	this.vEndIndex = vEndIndex;
                	this.face1Index = face1Index;
                	this.face2Index = face2Index;
                	this.isdt = isdt;
                }
               }

            class FaceInfo
            {
               	constructor(edgeIndices)
               	{
               		this.edgeIndices = edgeIndices;
               	}

             	getSubsetExcludingIndex(indexToExclude)
                {
                	var result = [];
                	this.edgeIndices.forEach(function (edgeIndex, index, array)
                	{
                		if(edgeIndex != indexToExclude)
                			result.push(edgeIndex);
                	});

                	return result;
                }
               }

            class IntersectionInfo
            {
 
              	constructor(u, v, edgeIndex, checked = false)
               	{
               		this.u = u;
               		this.v = v;
               		this.edgeIndex = edgeIndex;
               		this.checked = checked;
               	}

               	clone()
               	{
               		return new IntersectionInfo(this.u, this.v, this.edgeIndex, this.checked);
               	}
            }

            class rst
        	{
        		constructor(r, s, t)
        		{
        			this.r = r;
        			this.s = s;
        			this.t = t;
        		}
        	}


            function drawScene()
            {
	            var sourcePoint = sourceCylinderPos.clone();
	            sourcePoint.z -= sourceCylinder.geometry.parameters.height;
	            var sourceEndPoint = sourceCylinderPos.clone();
	            sourceEndPoint.z += sourceCylinder.geometry.parameters.height;
	            var sourceDir = new THREE.Vector3();
	            sourceDir.subVectors(sourceEndPoint, sourcePoint);

				if(controls.drawDebugElements)
				{
	    	        var arrowHelper = new THREE.ArrowHelper(sourceDir, sourcePoint, sourceDir.length(), 0xff0000);
					scene.add(arrowHelper);
				}

				function calculateDistanceSurfaceGeometry(distanceSurfaceGeometry, mainSurfaceVertices, mainSurfaceFaces, uvs)
				{
					var distanceSurfaceVertices = new Array(mainSurfaceVertices.length);

	                mainSurfaceFaces.forEach(function(face, index, array)
	                {
	                	function f(vertexIndex, faceVertexIndex)
	                	{
							if(typeof distanceSurfaceVertices[vertexIndex] === "undefined")
							{
								var bxn = new THREE.Vector3();
								bxn.crossVectors(sourceDir, face.vertexNormals[faceVertexIndex]);

								var qa = new THREE.Vector3();
								qa.subVectors(sourcePoint, mainSurfaceVertices[vertexIndex]);

								var d = bxn.dot(qa) / bxn.length();

								distanceSurfaceVertices[vertexIndex] = new THREE.Vector3(uvs[vertexIndex].u,
																				   		 uvs[vertexIndex].v,
																				   		 d);
							}
						}

						var faceCopy = face.clone();
						f(faceCopy.a, 0);
						f(faceCopy.b, 1);
						f(faceCopy.c, 2);

						distanceSurfaceGeometry.faces.push(faceCopy);
	                });

	                distanceSurfaceGeometry.vertices = distanceSurfaceVertices;
	                distanceSurfaceGeometry.computeFaceNormals();
	                distanceSurfaceGeometry.computeVertexNormals();
	                var distanceSurfaceMaterial = new THREE.MeshLambertMaterial({color: 0x0000ff, wireframe: controls.vizualizeAsWireframe});
	                var distanceSurface = new THREE.Mesh(distanceSurfaceGeometry, distanceSurfaceMaterial);
	                distanceSurface.material.side = THREE.DoubleSide;

	                if(controls.drawAuxSurface)
	             	{
	             		scene.add(distanceSurface);
	            	}
				}

				function calculateReflectionsForRarius(c, edgesInfo, facesInfo, distanceSurfaceGeometry, controlPoints, maxDistance, isTriangle = false)
            	{
	                var planeNormal = new THREE.Vector3(0, 0, 1);

	                var intersectionsInfo = [];

	                edgesInfo.forEach(function(edge, index, array)
	                {
	                	//reset the value to recalculate it correctly later
	                	edge.isdt = -1;

	                	var edgeStart = distanceSurfaceGeometry.vertices[edge.vBeginIndex].clone();
	                	var edgeEnd = distanceSurfaceGeometry.vertices[edge.vEndIndex].clone();

	                	if(checkLinePlaneIntersection(planeNormal, edgeStart, edgeEnd))
	                	{
	                		var intersectionPoint = getLinePlaneIntersectionPoint(planeNormal, c, edgeStart, edgeEnd);
	                		if(intersectionPoint != null)
	                		{
	                			intersectionsInfo.push(new IntersectionInfo(intersectionPoint.x, intersectionPoint.y, index));
	                			edge.isdt = intersectionsInfo.length - 1;
	                		}
	                	}
	                });

	                var contours = [];

	                function getIntersectionInexesForEdge(edgeIndex)
	                {
	                	var result = [];

	                	var isdt = edgesInfo[edgeIndex].isdt;
	                	if(isdt != -1)
	                		result.push(isdt);

	                	return result;
	                }

	                function getUncheckedIntersectionIndex()
	                {
	                	for(var i = 0; i < intersectionsInfo.length; i++)
	                	{
	                		if(!intersectionsInfo[i].checked)
	                			return i;
	                	}

	                	return -1;
	                }

	                while(true)
	                {
	                	var index = getUncheckedIntersectionIndex();
	                	if(index == -1)
	                		break;

		                contours.push([]);

		                while(true)
		                {	
	                		function checkFace(faceIndex, intersectionFoundHandler)
	                		{       	
				                if(faceIndex < 0 || faceIndex >= facesInfo.length)
				                {
				                	console.log("Invalid face index : " + faceIndex);
				                	return false;
				                }
				                	
				                var faceInfo = facesInfo[faceIndex];

			                	var otherEdges = faceInfo.getSubsetExcludingIndex(intersectionsInfo[index].edgeIndex);
			                	var intersectionFound = false;
			                	for(var j = 0; j < otherEdges.length; j++)
			                	{
			                		var intersectionIndexes = getIntersectionInexesForEdge(otherEdges[j]);
			                		if(intersectionIndexes.length == 1)
			                		{
			                			var newId = intersectionIndexes[0];
			                			if(intersectionsInfo[newId].checked)
			                				continue;

			                			intersectionFoundHandler();
			                			index = newId;
			                			return true;
			                		}
			                	}

			                	return false;
			                }

			                if(!(checkFace(edgesInfo[intersectionsInfo[index].edgeIndex].face1Index,
			                	function ()
			                	{
			                		intersectionsInfo[index].checked = true;
				            		contours[contours.length - 1].push(intersectionsInfo[index].clone());
			                	}) ||
			                	checkFace(edgesInfo[intersectionsInfo[index].edgeIndex].face2Index, 
			                	function ()
			                	{
			                		intersectionsInfo[index].checked = true;
				            		contours[contours.length - 1].push(intersectionsInfo[index].clone());
			                	})))
			                {
			                	intersectionsInfo[index].checked = true;
				            	contours[contours.length - 1].push(intersectionsInfo[index].clone());
				            	break;
			                } 
	                	}
	                }
					
					contours.forEach(function(contour, index, array)
					{
						var contour3dPoints = [[]];
						
						contour.forEach(function(point, index, array)
						{
							var point3d =  null;
							if(isTriangle)
							{
								point3d = calcCubicBezierTriangleValue(triSurfaceDegree, controlPoints, new rst(1 - point.u - point.v, point.v, point.u));
							}
							else
							{
								point3d = getSurfacePointAt(point.u, point.v, controlPoints);
							}

							var lastContour = last(contour3dPoints);
							var lastPoint = last(lastContour);
							if(lastPoint != null)
							{
								var distance = lastPoint.distanceTo(point3d);
								if(distance > maxDistance)
								{
									contour3dPoints.push([]);
								}
							}
							
							contour3dPoints[contour3dPoints.length - 1].push(point3d);
						});

						contour3dPoints.forEach(function(points, index, array)
						{
							if(points.length <= 1)
							{
								if(points.length == 1)
								{
									console.log("Single point contour");
									//scene.add(createSphere(contour3dPoints[0], 0x000000, "", 0.2));
								}
							}
							else
							{
								var curve = new THREE.CatmullRomCurve3(points, false);
								var points = curve.getPoints(points.length);
								var geometry = new THREE.BufferGeometry().setFromPoints(points);

								var lineWidth =  3;
								var color = 0x00ff00;

								var material = new THREE.LineBasicMaterial( { color : color , linewidth : lineWidth} );
								var curveObject = new THREE.Line( geometry, material );
								
								scene.add(curveObject);
							}
						});
					});
				}
	                
	            function drawBezierSurface(controlPoints, color)
	            {
	                var basicBezierModel = [];  //n bezier curves calculated from bezier control points

	                // calculating basic bezier model (main n bezier curves)
	                for (var i = 0; i < controlPoints.length; i++)
	                {
	                    basicBezierModel.push(bezierCurvePoints(controlPoints[i]));
	                    bezierCurveDivisions = basicBezierModel[0].length - 1;
	                }

	                var bezierCurvesVertices = [];

					for (var i = 0; i < bezierCurveDivisions + 1; i++)
					{
						var points = [];
	                	basicBezierModel.forEach(function(pointArr, index, array)
	                	{
	                		points.push(pointArr[i]);
	                	});


	                 	bezierCurvesVertices = bezierCurvesVertices.concat(bezierCurvePoints(points));
	                }

	                var uvs = getUv(bezierCurveDivisions);

	                // now we've got full bezier model, it's time to create bezier surface and add it to the scene
	                var bezierSurfaceVertices = bezierCurvesVertices;
	                var bezierSurfaceFaces = [];

	                var initUvSurfaceVertices = (uvSurfaceVertices.length == 0);
	                if(initUvSurfaceVertices)
	                	bezierSurfaceVertices.forEach(function(item, index, array)
	                	{
	                		uvSurfaceVertices.push(item.clone());
	               	 	});

	                var edgesInfo = [];
	                var facesInfo = [];

	                // creating faces from vertices
	                var currentFaceIndex = 0;
	                var v1, v2, v2;  // vertex indices in bezierSurfaceVertices array
	                for (var i = 0; i < bezierCurveDivisions; i++)
	                {
	                    for (var j = 0; j < bezierCurveDivisions; j++)
	                    {
	                    	function checkIndex(v)
	                    	{
	                    		if(v > bezierSurfaceVertices.length - 1)
	                    		{
	                    			console.log("Out of range : " + v);
	                    			return false;
	                    		}

	                    		return true;
	                    	}
	                    	function check(v1, v2, v3)
	                    	{
	                    		return (checkIndex(v1) &&
	                    				checkIndex(v2) &&
	                    				checkIndex(v3));
	                    	}

	                        v1 = i * (bezierCurveDivisions + 1) + j;
	                        v2 = (i + 1) * (bezierCurveDivisions + 1) + j; 
	                        v3 = i * (bezierCurveDivisions + 1) + (j + 1); 
	                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));

	                        //e1
	                        var f1 = currentFaceIndex - 1;
	                        var f2 = currentFaceIndex;
	                        if(j == 0)
	                        	f1 = -1;
	                        edgesInfo.push(new EdgeInfo(v1, v2, f1, f2));

	                        //e2
	                        f1 = currentFaceIndex;
	                        f2 = currentFaceIndex + 1;
	                        edgesInfo.push(new EdgeInfo(v2, v3, f1, f2));

	                        //e3
	                        f1 = ((i - 1) * (bezierCurveDivisions + 1) + (j * 2));
	                        f2 = currentFaceIndex;
	                        if(i == 0)
	                        	f1 = -1;
	                        edgesInfo.push(new EdgeInfo(v3, v1, f1, f2));

	                        facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));

	                        v1 = (i + 1) * (bezierCurveDivisions + 1) + j; 
	                        v2 = (i + 1) * (bezierCurveDivisions + 1) + (j + 1);
	                        v3 = i * (bezierCurveDivisions + 1) + (j + 1);
	                        bezierSurfaceFaces.push(new THREE.Face3(v1, v2, v3));

	                        currentFaceIndex++;

	                        //e4
	                        f1 = currentFaceIndex;
	                        f2 = (i + 1) * (bezierCurveDivisions + 1) + (j * 2);
	                        if(i > bezierCurveDivisions - 1)
	                        	f2 = -1;
	                        edgesInfo.push(new EdgeInfo(v1, v2, f1, f2));

	                        //e5
	                        f1 = currentFaceIndex;
	                        f2 = currentFaceIndex + 1;
	                        if(j > bezierCurveDivisions - 1)
	                        	f2 = -1;
	                        edgesInfo.push(new EdgeInfo(v2, v3, f1, f2));

	                        //e6
	                        f1 = currentFaceIndex;
	                        f2 = currentFaceIndex + 1;
	                        edgesInfo.push(new EdgeInfo(v3, v1, f1, f2));

	                        facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));

	                        currentFaceIndex++;
	                    }
	                }

	                var bezierSurfaceGeometry = new THREE.Geometry();
	                bezierSurfaceGeometry.vertices = bezierSurfaceVertices;
	                bezierSurfaceGeometry.faces = bezierSurfaceFaces;
	                bezierSurfaceGeometry.computeFaceNormals();
	                bezierSurfaceGeometry.computeVertexNormals();
	                var bezierSurfaceMaterial = new THREE.MeshLambertMaterial({color: color, wireframe: controls.vizualizeAsWireframe});
	                var bezierSurface = new THREE.Mesh(bezierSurfaceGeometry, bezierSurfaceMaterial);
	                bezierSurface.material.side = THREE.DoubleSide;
	                if(controls.drawPlane)
	                	scene.add(bezierSurface);

	                //distance surface

	                var distanceSurfaceGeometry = new THREE.Geometry();

	                calculateDistanceSurfaceGeometry(distanceSurfaceGeometry, bezierSurfaceVertices, bezierSurfaceFaces, uvs)

	                var firstFace = bezierSurfaceGeometry.faces[0];
	                var va = bezierSurfaceGeometry.vertices[firstFace.a];
	                var vb = bezierSurfaceGeometry.vertices[firstFace.b];
	                var maxDistance =  va.distanceTo(vb) * 2.0;
	                
	            	for(var i = 0; i <= controls.reflectionWidth; i++)
	                {
	                	calculateReflectionsForRarius(controls.radius * i, edgesInfo, facesInfo, distanceSurfaceGeometry, controlPoints, maxDistance);
	                	if(i > 0)
							calculateReflectionsForRarius(-controls.radius * i, edgesInfo, facesInfo, distanceSurfaceGeometry, controlPoints, maxDistance);
					}

					if(controls.drawDebugElements)
					{
	                	scene.add(createSphere(sourcePoint, 0x00ff00));
	                	scene.add(createSphere(sourceEndPoint, 0x00ff00));
	            	}
	            }


				function bernstein(i, j, k, rst, n = 3)
	  			{
	  				function fact(n)
	  				{
	  					if(n <= 1)
	  						return 1;
	  					return n * fact(n - 1);
	  				}

	    			return rst.r**i * rst.s**j * rst.t**k * fact(n) / (fact(i) * fact(j) * fact(k));  
	  			}

				function calcCubicBezierTriangleValue(n, controlPoints, rst)
  				{
    				let p = controlPoints, b = [];

    				let bIndex = 0;
    				for(let i = n; i >= 0; i--)
    				{
    					for(let j = 0; (i + j) <= n; j++)
    					{
    						b[bIndex] = bernstein(i, j, n - i -j, rst);
    						bIndex++;
    					}
    				}

    				let x = 0, y = 0, z = 0;
    				for(let i = 0; i < bIndex; i++)
    				{
      					x += p[i].x * b[i];
      					y += p[i].y * b[i];
      					z += p[i].z * b[i];
    				}

    				return new THREE.Vector3(x, y, z);
  				}

	            function drawBezierTriangularSurface(controlPoints, color)
	            {
	            	function getBarycentricCoords(n)
	            	{
	    				var rstArr = [];
	    				for(let i = 0; i <= n; i++)
	    				{
	    					for(let j= 0; j <= n - i; j++)
	    					{
	     						let s = (j / n);
	      						let t = (i / n);    
	      						let r = 1 - s - t;
	      						rstArr.push(new rst(r, s, t));    
	    					}
	    				}

	    				return rstArr;
	  				}

	  				var edgesInfo = [];
	                var facesInfo = [];
	                var uvs = [];

	  				function genTrianglesIndexes(n)
	  				{
	    				let st = 0; 
	    				let m = n;  
	    				let triangles = [];

	    				var currentFaceIndex = 0;


	    				for(let j = n; j > 0; j--)
	    				{    
	      					for(let i = 0; i < m; i++)
	      					{    
	      						var v1 = st + i;
	      						var v2 = st + i + 1;
	      						var v3 = st + m + i + 1;

	      						//e1
	      						var f1 = currentFaceIndex - (2 * (m - 1));
	      						if(j == n)
	      							f1 = -1;
	      						var f2 = currentFaceIndex;
	      						edgesInfo.push(new EdgeInfo(v1, v2, f1, f2));

	      						//e2
	      						f1 = currentFaceIndex;
	      						f2 = currentFaceIndex + 1;
	      						if(i ==  m - 1)
	      							f2 = -1;
	      						edgesInfo.push(new EdgeInfo(v2, v3, f1, f2));

	      						//e3
	      						f1 = currentFaceIndex;
	      						f2 = currentFaceIndex - 1;
	      						if(i == 0)
	      							f2 = -1;
	      						edgesInfo.push(new EdgeInfo(v3, v1, f1, f2));

	      						facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));

	        					triangles.push(new THREE.Face3(v1, v2, v3));
	        					
	        					currentFaceIndex++;

	         					if(i < m - 1)
	        					{
	        						var v4 = st + i + 1;
	      							var v5 = st + m + i + 2;
	      							var v6 = st + m + i + 1;
	      							
	      							//e4
	      							f1 = currentFaceIndex + 1;
	      							f2 = currentFaceIndex;
	      							edgesInfo.push(new EdgeInfo(v4, v5, f1, f2));

	      							//e5
	      							f1 = currentFaceIndex;
	      							f2 = currentFaceIndex + (2 * (m - 2));
	      							edgesInfo.push(new EdgeInfo(v5, v6, f1, f2));

	      							//e6
	      							f1 = currentFaceIndex;
	      							f2 = currentFaceIndex - 1;
	      							edgesInfo.push(new EdgeInfo(v6, v4, f1, f2));

									facesInfo.push(new FaceInfo([edgesInfo.length - 3, edgesInfo.length - 2, edgesInfo.length - 1]));
	         						
	         						triangles.push(new THREE.Face3(v4, v5, v6));
	         					    
	         					    currentFaceIndex++;
								}
							}
	      					
	     					m--;
	      					st += j + 1;  
	    				}

	    				return triangles;
	  				}

	            	function genTrianglesForCubicBezierTriangle(nTriangles, controlPoints, geom)
	            	{
	    				var barycentricCoords = getBarycentricCoords(nTriangles); // domain in barycentric coordinates   
	    				var trianglesIndexes = genTrianglesIndexes(nTriangles); // indexes of triangles (in bar array)
	        
	    				var points = [];
	    				barycentricCoords.forEach(function (rst, index, array)
	    				{
	    					points.push(calcCubicBezierTriangleValue(triSurfaceDegree, controlPoints, rst));
	    					uvs.push(new uv(rst.t, rst.s));
	    				});

	    				geom.vertices = points;
	    				geom.faces = trianglesIndexes;
	    			}

					
	    			var triangularBezierSurfaceGeometry = new THREE.Geometry();
	    			genTrianglesForCubicBezierTriangle(25, controlPoints, triangularBezierSurfaceGeometry);
	                
	                triangularBezierSurfaceGeometry.computeFaceNormals();
	                triangularBezierSurfaceGeometry.computeVertexNormals();
	                var bezierSurfaceMaterial = new THREE.MeshLambertMaterial({color: color, wireframe: controls.vizualizeAsWireframe});
	                var triangularBezierSurface = new THREE.Mesh(triangularBezierSurfaceGeometry, bezierSurfaceMaterial);
	                triangularBezierSurface.material.side = THREE.DoubleSide;
	                if(controls.drawPlane)
	                 	scene.add(triangularBezierSurface);

	                var distanceSurfaceGeometry = new THREE.Geometry();

	                calculateDistanceSurfaceGeometry(distanceSurfaceGeometry, triangularBezierSurfaceGeometry.vertices,
	                								 triangularBezierSurfaceGeometry.faces, uvs);

	                var firstFace = triangularBezierSurfaceGeometry.faces[0];
	                var va = triangularBezierSurfaceGeometry.vertices[firstFace.a];
	                var vb = triangularBezierSurfaceGeometry.vertices[firstFace.b];
	                var maxDistance =  va.distanceTo(vb) * 2.0;

	                for(var i = 0; i <= controls.reflectionWidth; i++)
	                {
	                	calculateReflectionsForRarius(controls.radius * i, edgesInfo, facesInfo, distanceSurfaceGeometry, controlPoints, maxDistance, true);
	                	if(i > 0)
							calculateReflectionsForRarius(-controls.radius * i, edgesInfo, facesInfo, distanceSurfaceGeometry, controlPoints, maxDistance, true);
					}
	    		}

	    		if(trianglesControlPointsScaled.length == 0)
	    			trianglesControlPointsScaled = trianglesControlPoints;

	    		if(controlPointsArrScaled.length == 0)
	    			controlPointsArrScaled = controlPointsArr;

	    		trianglesControlPointsScaled.forEach(function (points, index, array)
	    		{
	    			drawBezierTriangularSurface(points, controls.color);
	    		});
	    		controlPointsArrScaled.forEach(function (points, index, array)
	    		{
					drawBezierSurface(points, controls.color);
				});

				scene.add(lightBelow); 
	            scene.add(lightAbove);
				scene.add(lightLeft); 
	            scene.add(lightRight);

	    		if(controls.drawDebugElements)
				{
                	scene.add(createSphere(sourcePoint, 0x00ff00));
                	scene.add(createSphere(sourceEndPoint, 0x00ff00));
            	}
	    	}

	    	function getScalePoints(points, scale)
	    	{
	    		var result = [];

	    		points.forEach(function (point, index, array)
				{
					var id = new THREE.Vector3();
					result.push(id.addScaledVector(point, scale));
				});

				return result;
	    	}

	    	function handlePlaneScale(scale)
	    	{
	    		controlPointsArrScaled = []
	    		controlPointsArr.forEach(function (pointsMesh, index, array)
	    		{
	    			var scaledMesh = [];
	    			pointsMesh.forEach(function (points, index, array)
	    			{
	    				scaledMesh.push(getScalePoints(points, scale));
	    			});
	    			controlPointsArrScaled.push(scaledMesh);
				});

				trianglesControlPointsScaled = []
	    		trianglesControlPoints.forEach(function (points, index, array)
	    		{
	    			trianglesControlPointsScaled.push(getScalePoints(points, scale));
				});

	    		update();
	    	}
	    		
            function createSphere(pos, color, name = "", radius = 0.7, )
            {
            	var sphereGeometry = new THREE.SphereGeometry(radius, 10, 10);
                            
	            var sphereMaterial = new THREE.MeshBasicMaterial({color: color});
	            var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
	            sphere.name = name;
	            sphere.position.x = pos.x;
	            sphere.position.y = pos.y;
	            sphere.position.z = pos.z;
 
	            return sphere;
	        }
            
            function generateControlPointsSpheres(controlPoints, spheres, pointsColor)
            {
               var meshSize = controlPoints.length;
               var rowSize = controlPoints[0].length;
                
                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < rowSize; j++)
                    {
                        spheres.push(createSphere(controlPoints[i][j], pointsColor, i.toString() + "-" + j.toString()));
                    }
                }
            }
                
            function drawControlMesh(controlPoints, controlSpheres, pointsColor, linesColor)
            {
                console.log("drawControlMesh");
                
                controlSpheres.length = 0;
                
                generateControlPointsSpheres(controlPoints, controlSpheres, pointsColor);
                                
                var meshSize = controlPoints.length;
                var rowSize = controlPoints[0].length;

                for(var i = 0; i < meshSize; i++)
                {
                    for(var j = 0; j < rowSize; j++)
                    {
                        scene.add(controlSpheres[i * meshSize + j]);
                        
                        if(j > 0)
                            drawLine(controlPoints[i][j - 1], controlPoints[i][j], linesColor);
                        
                        if(i > 0)
                            drawLine(controlPoints[i - 1][j], controlPoints[i][j], linesColor);
                    }
                }
            }

            function drawLine(p1, p2, color, width = 1)
            {
            	drawLineMultiplePoints([p1, p2], color, width);
            }
            
            function drawLineMultiplePoints(points, color, width =  1)
            {
                var geometry = new THREE.Geometry();

                geometry.vertices = points;
                
                var material = new THREE.LineBasicMaterial({color : color, linewidth : width});
                
                var line = new THREE.Line(geometry, material);
                
                scene.add(line);
            }

            function drawSourceCylinder()
            {
				var cylinderGeometry = new THREE.CylinderGeometry(controls.reflectionWidth, controls.reflectionWidth, 20, 32);
				cylinderGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 2));
				var opacity = 1.0;
				if(controls.drawDebugElements)
					opacity = 0.5;
				var material = new THREE.MeshLambertMaterial({color: 0xffff00, emissive: 0xffff00, transparent : true,
															  emissiveIntensity : 0.75, opacity : opacity});
				sourceCylinder = new THREE.Mesh(cylinderGeometry, material);
				sourceCylinder.position.x = sourceCylinderPos.x;
				sourceCylinder.position.y = sourceCylinderPos.y;
				sourceCylinder.position.z = sourceCylinderPos.z;
				scene.add(sourceCylinder);
			}

			function drawPlane(y = 10)
            {
            	var planeGeometry = new THREE.PlaneGeometry(60, 60);
            	planeGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 2));
            	planeGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(20, y, 0));
				var material = new THREE.MeshLambertMaterial({color: 0xff00ff, wireframe: controls.vizualizeAsWireframe});
				var plane = new THREE.Mesh(planeGeometry, material);
				scene.add(plane);
            }

            function handleControlSphereClick(selectedSphere)
            {
            	console.log("Control point shpere clicked");

            	renderScene();
                var planeNormal = selectedSphere.position.clone().sub(camera.position);
                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, selectedSphere.position);
                
                $(document).on("mousemove", function(e)
                {
                    var mouseMove = new THREE.Vector3();
                    mouseMove.x = (e.clientX / renderer.domElement.width) * 2 - 1;
                    mouseMove.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
                    mouseMove.z = 1;
                    mouseMove.unproject(camera);
                    var ray = new THREE.Ray(camera.position, mouseMove.sub(camera.position).normalize());
                    var intersection = ray.intersectPlane(plane, new THREE.Vector3());
                    
                    selectedSphere.position.set(intersection.x, intersection.y, intersection.z);
                    var i = selectedSphere.name.split("-"); 
                    controlPoints[ i[0] ][ i[1] ] = new THREE.Vector3(intersection.x, intersection.y, intersection.z);
                    update();
                });
            }

			function handleSourceCylinderClick()
            {
                var planeNormal = sourceCylinder.position.clone().sub(camera.position);
                var plane = new THREE.Plane();
                plane.setFromNormalAndCoplanarPoint(planeNormal, sourceCylinder.position);
                
                $(document).on("mousemove", function(e)
                {
                    var mouseMove = new THREE.Vector3();
                    mouseMove.x = (e.clientX / renderer.domElement.width) * 2 - 1;
                    mouseMove.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
                    mouseMove.z = 1;
                    mouseMove.unproject(camera);
                    var ray = new THREE.Ray(camera.position, mouseMove.sub(camera.position).normalize());
                    var intersection = new THREE.Vector3();
                    ray.intersectPlane(plane, intersection);
                    sourceCylinderPos = intersection.clone();
                    update();
                });
            }

            document.addEventListener("mousedown", onClick, true);  
            function onClick(e)
			{
                console.log("mousedown");

				var cursorPos = new THREE.Vector2();
				var raycaster = new THREE.Raycaster();
				
				cursorPos.x = (e.clientX / renderer.domElement.width) * 2 - 1;
				cursorPos.y = - (e.clientY / renderer.domElement.height) * 2 + 1;
				raycaster.setFromCamera(cursorPos, camera);
							
				//check control spheres for intersecdtions
				var intersectedObjects = raycaster.intersectObjects(controlPointsSpheres);
				
				if(intersectedObjects.length > 0)
				{   
	                cameraControls.enabled = false;  // disabling camera rotation
	                
	                var selectedSphere = intersectedObjects[0].object;
	                if(!selectedSphere.visible)
	                {
	                	cameraControls.enabled = controls.interactiveCamera;
	                	console.log("intersected sphere invisible");
	                    return;
	                }
	                
	                handleControlSphereClick(selectedSphere);
	            }
	            else
	            {
	            	var intersectedObjects = raycaster.intersectObjects([sourceCylinder]);
	            	if(intersectedObjects.length > 0)
					{   
	                	cameraControls.enabled = false;  // disabling camera 
	                	handleSourceCylinderClick();
	            	}
	            	else
	            	{
	            		cameraControls.enabled = controls.interactiveCamera;
	            		console.log("No interactions");
	            		return;
	            	}
	            }
                
                $(document).on("mouseup", function(e)
                {
                    $(document).off("mousemove");
                    $(document).off("mouseup");
                    cameraControls.enabled = controls.interactiveCamera;  // enabling camera controls again
                });
            }

            
            document.addEventListener("keydown", onKeypress);
            function onKeypress(e)
            {
            	console.log("Key pressed : " + e.code);

            	if(e.code == "Space")
            	{
            		controls.drawDebugElements = !controls.drawDebugElements;
            		update();
            	}
            }

            function renderScene()
            {
				renderer.render(scene, camera);
			}
			
			function update()
			{
				while(scene.children.length > 0)
				{ 
    				scene.remove(scene.children[0]); 
				}

				drawSourceCylinder();

				drawScene();
            	var controlMeshColor = 0x000000;
            	if(controls.showControlPoints && controlPointsArr.length > 0)
            		drawControlMesh(controlPointsArr[0], controlPointsSpheres, controlMeshColor, controlMeshColor);

            	if(controls.showAxisHelper)
            		scene.add(axisHelper);

                renderScene();
			}
			 
			$("#WebGL-output").append(renderer.domElement);

			update();
		});
		</script>
	</body>
</html>
